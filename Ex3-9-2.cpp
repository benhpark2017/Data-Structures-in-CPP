/**
 * Solutions to Chapter 3, Section 9, Exercise 2 of Horowitz's
 * Fundamentals of Data Structure in C++.
 * 
 * We want to simulate an airport landing and takeoff pattern. 
 * The airport has three  runways, runway 1, runway 2, and runway
 * 3. There are four landing holding patterns, two for each of
 * the first two runways. Arriving planes will enter one of the 
 * holding pattern queues, where the queues are to be as close in 
 * size as possible. When a plane enters a holding queue, it is 
 * assigned an integer "id" number and an integer giving the 
 * number of time units the plane can remain in the queue 
 * before it must land (because of low fuel level). There is 
 * also a queue for takeoffs for each of the three runways. 
 * Planes arriving in a takeoff queue are also to be assigned 
 * an integer "id". The takeoff queues should be kept 
 * approximately the same size.
 * 
 * At each time, up to three planes may arrive at the landing
 * queues and up to three planes may arrive at the takeoff queues. 
 * Each runway can handle one takeoff or landing at each time slot. 
 * Runway 3 is to be used for takeoffs except when a plane is
 * low on fuel. At each time unit, planes in either landing 
 * queue whose air time has reached zero must be given priority
 * over other landings and takeoffs. If only one plane is in
 * this category, runway 3 is to be used. If more than one,
 * then the other runways are also used (at each time, at most
 * three planes can be serviced this way).
 * 
 * Use successive even (odd) integers for "id"'s of planes
 * arriving at takeoff (landing) queues. At each time unit 
 * assume that arriving planes are entered into queues before 
 * takeoffs or landings occur. Try to design your algorithm 
 * so that neither landing nor takeoff queues grow excessively.
 * However, arriving planes must be placed at the ends of queues.
 * Queues cannot be reordered.
 * 
 * The output should clearly indicate what occurs at each time unit.
 * Periodically output (a) the contents of each queue; (b) the
 * average takeoff waiting time; (c) the average landing waiting
 * time; (d) the average flying time remaining on landing; and
 * (e) the number of planes landing with no fuel reserve. (b)
 * and (c) are for planes that have taken off or landed,
 * respectively. The output should be self-explanatory and easy
 * to understand, and the code should be uncluttered.
 * 
 * The input can be generated by a random number generator. For 
 * each time unit the input consists of the number of planes 
 * arriving at takeoff queues, the number of planes arriving 
 * at landing queues, and the remaining flying times for each
 * plane arriving at a landing queue.
 * 
 */

/*********************************main.cpp*************************************/
#include <iostream>
#include <queue>
#include <vector>
#include <random>
#include <ctime>
#include <algorithm>
#include "Plane.h"
#include "QueueManagement.h"
#include "RunwayProcessing.h"

// Include the global variables from RunwayProcessing.h
extern int totalLandedPlanes;
extern int totalTakenOffPlanes;
extern int totalLandingWaitTime;
extern int totalTakeoffWaitTime;
extern int totalRemainingFuel;
extern int planesLandedWithNoFuelReserve;

int main() {
    std::srand(std::time(nullptr));  // Seed for random number generation

    std::vector<std::queue<Plane>> landingQueues(4);  // 4 landing queues
    std::vector<std::queue<Plane>> takeoffQueues(3);  // 3 takeoff queues
    int planeId = 1;
    int simulationTime = 100;  // Run simulation for 100 time units



    for (int time = 0; time < simulationTime; ++time) {
        std::cout << "Time: " << time << std::endl;

        generateArrivals(landingQueues, takeoffQueues, planeId, time);
        processRunways(landingQueues, takeoffQueues, time, totalLandedPlanes, totalTakenOffPlanes,
                       planesLandedWithNoFuelReserve, totalLandingWaitTime, totalTakeoffWaitTime, totalRemainingFuel);

        if (time % 10 == 0) {  // Print statistics every 10 time units
            printQueueContents(landingQueues, takeoffQueues);
            printStatistics(time, totalLandedPlanes, totalTakenOffPlanes, planesLandedWithNoFuelReserve,
                            totalLandingWaitTime, totalTakeoffWaitTime, totalRemainingFuel);
        }
    }

    return 0;
}


/****************************Plane.h******************************/
#ifndef PLANE_H
#define PLANE_H

#include <iostream>

struct Plane {
    int id;
    int fuel;
    int arrivalTime;
    int waitingTime;
    int initialFuel;

    Plane(int id, int fuel, int arrivalTime)
        : id(id), fuel(fuel), arrivalTime(arrivalTime), waitingTime(0), initialFuel(fuel) {}
};

// Global variables for statistics
extern int totalLandedPlanes;
extern int totalTakenOffPlanes;
extern int totalLandingWaitTime;
extern int totalTakeoffWaitTime;
extern int totalRemainingFuel;
extern int planesLandedWithNoFuelReserve;

#endif // PLANE_H



/**************************QueueManagement.h***************************/
#ifndef QUEUE_MANAGEMENT_H
#define QUEUE_MANAGEMENT_H

#include <vector>
#include <queue>
#include "Plane.h"

// Function prototypes
void generateArrivals(std::vector<std::queue<Plane>>& landingQueues, std::vector<std::queue<Plane>>& takeoffQueues, int& planeId, int time);
void printQueueContents(const std::vector<std::queue<Plane>>& landingQueues, const std::vector<std::queue<Plane>>& takeoffQueues);
void updateWaitingTimes(std::vector<std::queue<Plane>>& landingQueues, std::vector<std::queue<Plane>>& takeoffQueues);
void printStatistics(int time, int totalLandedPlanes, int totalTakenOffPlanes, int planesLandedWithNoFuel, int totalLandingWaitTime, int totalTakeoffWaitTime, int totalRemainingFuel);

#endif // QUEUE_MANAGEMENT_H



/*************************QueueManagement.cpp**************************/
#include "QueueManagement.h"
#include <random>
#include <algorithm>
#include <iostream>

void generateArrivals(std::vector<std::queue<Plane>>& landingQueues, std::vector<std::queue<Plane>>& takeoffQueues, int& planeId, int time) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> landingDist(0, 3);  // 0 to 3 planes can arrive for landing
    std::uniform_int_distribution<> takeoffDist(0, 3);  // 0 to 3 planes can arrive for takeoff
    std::uniform_int_distribution<> fuelDist(1, 20);    // Fuel range from 1 to 20 time units

    int landingArrivals = landingDist(gen);
    int takeoffArrivals = takeoffDist(gen);

    // Generate landing arrivals
    for (int i = 0; i < landingArrivals; ++i) {
        int fuel = fuelDist(gen);
        int queueIndex = std::min_element(landingQueues.begin(), landingQueues.end(),
            [](const std::queue<Plane>& a, const std::queue<Plane>& b) {
                return a.size() < b.size();
            }) - landingQueues.begin();

        landingQueues[queueIndex].emplace(planeId, fuel, time);
        planeId += 2;  // Odd IDs for landing planes
    }

    // Generate takeoff arrivals
    for (int i = 0; i < takeoffArrivals; ++i) {
        int queueIndex = std::min_element(takeoffQueues.begin(), takeoffQueues.end(),
            [](const std::queue<Plane>& a, const std::queue<Plane>& b) {
                return a.size() < b.size();
            }) - takeoffQueues.begin();

        takeoffQueues[queueIndex].emplace(planeId, 0, time);  // Takeoff planes don't need fuel
        planeId += 2;  // Even IDs for takeoff planes
    }
}

void printQueueContents(const std::vector<std::queue<Plane>>& landingQueues, const std::vector<std::queue<Plane>>& takeoffQueues) {
    std::cout << "Queue Contents:" << std::endl;

    std::cout << "Landing Queues:" << std::endl;
    for (size_t i = 0; i < landingQueues.size(); ++i) {
        std::cout << "  Queue " << i + 1 << ": ";
        auto tempQueue = landingQueues[i];
        while (!tempQueue.empty()) {
            std::cout << "[ID: " << tempQueue.front().id << ", Fuel: " << tempQueue.front().fuel << "] ";
            tempQueue.pop();
        }
        std::cout << std::endl;
    }

    std::cout << "Takeoff Queues:" << std::endl;
    for (size_t i = 0; i < takeoffQueues.size(); ++i) {
        std::cout << "  Queue " << i + 1 << ": ";
        auto tempQueue = takeoffQueues[i];
        while (!tempQueue.empty()) {
            std::cout << "[ID: " << tempQueue.front().id << "] ";
            tempQueue.pop();
        }
        std::cout << std::endl;
    }
}

void updateWaitingTimes(std::vector<std::queue<Plane>>& landingQueues, std::vector<std::queue<Plane>>& takeoffQueues) {
    for (auto& queue : landingQueues) {
        std::queue<Plane> tempQueue;
        while (!queue.empty()) {
            Plane plane = queue.front();
            queue.pop();
            plane.waitingTime++;
            tempQueue.push(plane);
        }
        queue = tempQueue;
    }

    for (auto& queue : takeoffQueues) {
        std::queue<Plane> tempQueue;
        while (!queue.empty()) {
            Plane plane = queue.front();
            queue.pop();
            plane.waitingTime++;
            tempQueue.push(plane);
        }
        queue = tempQueue;
    }
}

void printStatistics(int time, int totalLandedPlanes, int totalTakenOffPlanes, int planesLandedWithNoFuel, int totalLandingWaitTime, int totalTakeoffWaitTime, int totalRemainingFuel) {
    std::cout << "Statistics at time " << time << ":" << std::endl;

    if (totalLandedPlanes > 0) {
        std::cout << "Average landing waiting time: " << static_cast<double>(totalLandingWaitTime) / totalLandedPlanes << std::endl;
        std::cout << "Average flying time remaining on landing: " << static_cast<double>(totalRemainingFuel) / totalLandedPlanes << std::endl;
    } else {
        std::cout << "No planes have landed yet." << std::endl;
    }

    if (totalTakenOffPlanes > 0) {
        std::cout << "Average takeoff waiting time: " << static_cast<double>(totalTakeoffWaitTime) / totalTakenOffPlanes << std::endl;
    } else {
        std::cout << "No planes have taken off yet." << std::endl;
    }

    std::cout << "Number of planes landing with no fuel reserve: " << planesLandedWithNoFuel << std::endl;
}


/**********************RunwayProcessing.h**********************/
#ifndef RUNWAY_PROCESSING_H
#define RUNWAY_PROCESSING_H

#include <vector>
#include <queue>
#include "Plane.h"

// Function prototypes
void processRunways(std::vector<std::queue<Plane>>& landingQueues, std::vector<std::queue<Plane>>& takeoffQueues, int time, int& totalLandedPlanes, int& totalTakenOffPlanes, int& planesLandedWithNoFuel, int& totalLandingWaitTime, int& totalTakeoffWaitTime, int& totalRemainingFuel);

// Global variables (declared as extern)
extern int totalLandedPlanes;
extern int totalTakenOffPlanes;
extern int totalLandingWaitTime;
extern int totalTakeoffWaitTime;
extern int totalRemainingFuel;
extern int planesLandedWithNoFuelReserve;

#endif // RUNWAY_PROCESSING_H



/*********************RunwayProcessing.cpp*********************/
#include "RunwayProcessing.h"
#include <iostream>
#include <algorithm>

// Global variables for statistics
int totalLandedPlanes = 0;
int totalTakenOffPlanes = 0;
int totalLandingWaitTime = 0;
int totalTakeoffWaitTime = 0;
int totalRemainingFuel = 0;
int planesLandedWithNoFuelReserve = 0;

void processRunways(std::vector<std::queue<Plane>>& landingQueues, std::vector<std::queue<Plane>>& takeoffQueues, int time, int& totalLandedPlanes, int& totalTakenOffPlanes, int& planesLandedWithNoFuel, int& totalLandingWaitTime, int& totalTakeoffWaitTime, int& totalRemainingFuel) {
    const int lowFuelThreshold = 3;
    int planesProcessed = 0;

    // Process runway 1 and 2
    for (int runway = 0; runway < 2 && planesProcessed < 3; ++runway) {
        if (!landingQueues[runway * 2].empty() && !landingQueues[runway * 2 + 1].empty()) {
            // Choose the plane with lower fuel
            int queueIndex = (landingQueues[runway * 2].front().fuel <= landingQueues[runway * 2 + 1].front().fuel) ? runway * 2 : runway * 2 + 1;
            Plane landingPlane = landingQueues[queueIndex].front();
            std::cout << "Plane " << landingPlane.id << " landed on runway " << runway + 1 << std::endl;
            landingQueues[queueIndex].pop();
            planesProcessed++;

            totalLandingWaitTime += time - landingPlane.arrivalTime;
            totalRemainingFuel += landingPlane.fuel;
            totalLandedPlanes++;
            if (landingPlane.fuel == 0) planesLandedWithNoFuel++;
        } else if (!landingQueues[runway * 2].empty() || !landingQueues[runway * 2 + 1].empty()) {
            // Land the plane from the non-empty queue
            int queueIndex = landingQueues[runway * 2].empty() ? runway * 2 + 1 : runway * 2;
            Plane landingPlane = landingQueues[queueIndex].front();
            std::cout << "Plane " << landingPlane.id << " landed on runway " << runway + 1 << std::endl;
            landingQueues[queueIndex].pop();
            planesProcessed++;

            totalLandingWaitTime += time - landingPlane.arrivalTime;
            totalRemainingFuel += landingPlane.fuel;
            totalLandedPlanes++;
            if (landingPlane.fuel == 0) planesLandedWithNoFuel++;
        } else if (!takeoffQueues[runway].empty()) {
            // If no landings, process takeoff
            Plane takeoffPlane = takeoffQueues[runway].front();
            std::cout << "Plane " << takeoffPlane.id << " took off from runway " << runway + 1 << std::endl;
            takeoffQueues[runway].pop();
            planesProcessed++;

            totalTakeoffWaitTime += time - takeoffPlane.arrivalTime;
            totalTakenOffPlanes++;
        }
    }

    // Process runway 3
    if (planesProcessed < 3) {
        bool emergencyLanding = false;
        for (auto& queue : landingQueues) {
            if (!queue.empty() && queue.front().fuel <= lowFuelThreshold) {
                Plane landingPlane = queue.front();
                std::cout << "Emergency landing: Plane " << landingPlane.id << " landed on runway 3" << std::endl;
                queue.pop();
                emergencyLanding = true;
                planesProcessed++;

                totalLandingWaitTime += time - landingPlane.arrivalTime;
                totalRemainingFuel += landingPlane.fuel;
                totalLandedPlanes++;
                if (landingPlane.fuel == 0) planesLandedWithNoFuel++;
                break;
            }
        }

        if (!emergencyLanding && !takeoffQueues[2].empty()) {
            Plane takeoffPlane = takeoffQueues[2].front();
            std::cout << "Plane " << takeoffPlane.id << " took off from runway 3" << std::endl;
            takeoffQueues[2].pop();
            planesProcessed++;

            totalTakeoffWaitTime += time - takeoffPlane.arrivalTime;
            totalTakenOffPlanes++;
        }
    }

    // Decrease fuel for planes in landing queues
    for (auto& queue : landingQueues) {
        std::queue<Plane> tempQueue;
        while (!queue.empty()) {
            Plane plane = queue.front();
            queue.pop();
            plane.fuel--;
            if (plane.fuel > 0) {
                tempQueue.push(plane);
            } else {
                std::cout << "Plane " << plane.id << " has crashed due to fuel exhaustion!" << std::endl;
                planesLandedWithNoFuel++;
            }
        }
        queue = tempQueue;
    }
}


